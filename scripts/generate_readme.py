# file: scripts/generate_readme.py

import os
import time
import logging
import subprocess
import json
import importlib.util
from typing import Any, Dict, List, Tuple

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(message)s")

# Paths
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
PLUGIN_DIR = os.path.join(BASE_DIR, "../jax2onnx/plugins")
EXAMPLES_DIR = os.path.join(BASE_DIR, "../jax2onnx/examples")
TESTS_DIR = os.path.join(BASE_DIR, "../tests")
README_PATH = os.path.join(BASE_DIR, "../README.md")

# Markers for auto-generated sections in README.md
START_MARKER = "<!-- AUTOGENERATED TABLE START -->"
END_MARKER = "<!-- AUTOGENERATED TABLE END -->"
EXAMPLES_START_MARKER = "<!-- AUTOGENERATED EXAMPLES TABLE START -->"
EXAMPLES_END_MARKER = "<!-- AUTOGENERATED EXAMPLES TABLE END -->"

NETRON_BASE_URL = "https://netron.app/?url=https://enpasos.github.io/jax2onnx/onnx/"

# --- Helper Functions ---


def get_plugin_from_source(source: str) -> str:
    return source.split(".")[-1]


from tests.t_generator import (
    load_plugin_metadata,
    get_plugin_grouping,
    organize_tests_by_context_and_component_from_params,
)

# --- Running Tests ---


def run_pytest() -> Dict:
    """Runs pytest and captures pass/fail results using JSON output."""
    logging.info("üõ† Running full tests...")
    report_dir = os.path.join(BASE_DIR, "output")
    os.makedirs(report_dir, exist_ok=True)
    report_path = os.path.join(report_dir, "pytest_report.json")

    # subprocess.run(
    #     ["pytest", "--json-report", f"--json-report-file={report_path}"],
    #     capture_output=True,
    #     text=True,
    #     check=True,
    # )

    test_results = {}
    if os.path.exists(report_path):
        with open(report_path, "r", encoding="utf-8") as f:
            data = json.load(f)
        for test in data.get("tests", []):
            partA, partB, partC = test["nodeid"].split("::")
            partAs = partA.split("/")
            testcase_name = (
                partC.replace("test_", "") if partC.startswith("test_") else partC
            )
            situation = partAs[1]  # expecting "examples" or "primitives"
            context = partAs[-1]

            context = (
                context.replace("test_", "") if context.startswith("test_") else context
            )
            context = context.replace(".py", "") if context.endswith(".py") else context
            context = situation + "." + context
            plugin = partB.replace("Test_", "") if partB.startswith("Test_") else partB

            status = "‚úÖ" if test["outcome"] == "passed" else "‚ùå"
            key = (context, plugin, testcase_name)
            test_results[key] = status

    logging.info(f"‚úÖ Tests completed. {len(test_results)} results captured.")

    return test_results


# --- Metadata Extraction and Aggregation ---


def extract_metadata(base_path: str, source_type: str) -> List[Dict[str, Any]]:
    logging.info(f"üì° Extracting metadata from {source_type.lower()}s...")

    if source_type.lower() == "plugins":
        # Use the existing function that already handles metadata extraction
        metadata_list = load_plugin_metadata()

    # The existing normalization code can stay as is...

    logging.info(f"‚úÖ {len(metadata_list)} {source_type.lower()} components found.")
    return metadata_list


def aggregate_metadata(
    entries: List[Dict[str, Any]],
) -> Dict[Tuple[str, str], Dict[str, Any]]:
    """
    Group individual test case metadata entries by (context, component)
    and aggregate test case statuses.
    """
    # For plugins, use the existing grouping function
    return organize_tests_by_context_and_component_from_params(entries)


def merge_test_results(
    grouped: Dict[Tuple[str, str], Dict[str, Any]], test_results: Dict
) -> Dict[Tuple[str, str], Dict[str, Any]]:
    """
    Update the grouped metadata with test result statuses.
    Test result keys are tuples: (context, plugin, testcase).
    For plugins, we consider the plugin name as the short form of the jax component.
    """
    for (context, component), testcases in grouped.items():
        # Use plugin from jax_component (or component) to lookup test result.
        plugin = component

        # make a copy of data["testcases"] to avoid changing the original dict while iterating
        # copy = testcases.copy()
        for tc in testcases:
            tc_ = tc["testcase"]
            # if not in test_results print a comment
            if (context, plugin, tc_) not in test_results:
                logging.warning(
                    f"‚ùå Test case `{tc_}` not found in test results for {context} - {plugin}"
                )
            if (context, plugin, tc_) in test_results:
                status = test_results.get((context, plugin, tc_), "‚ûñ")
                url = f"{NETRON_BASE_URL}{context.replace('.', '/')}/{tc_}.onnx"
                # add attribute result to tc
                tc["result"] = f"[`{tc_}`]({url}) {status}"

    return grouped


# --- README Update ---


def update_readme(
    grouped_metadata,
    test_results: Dict,
):
    # filter grouped_metadata by key "examples
    examples_grouped = {
        k: v for k, v in grouped_metadata.items() if k[0].startswith("examples")
    }

    plugins_grouped = {
        k: v for k, v in grouped_metadata.items() if k[0].startswith("primitives")
    }

    # Merge test results into the aggregated groups.
    plugins_grouped = merge_test_results(plugins_grouped, test_results)
    examples_grouped = merge_test_results(examples_grouped, test_results)

    # Build table rows for plugins.
    plugin_rows = []
    for (context, component), data in sorted(plugins_grouped.items()):

        comp_name = component
        # Prepend context to the component name if it's not default
        # if context != "default":
        #     comp_name = f"{context}.{comp_name}"
        # Remove "plugin." prefix from the component name
        comp_name = comp_name.removeprefix("plugins.")

        jax_comp = f"[{comp_name}]({data[0]['jax_doc']})"
        onnx_components = (
            "<br>".join(
                sorted([f"[{x['component']}]({x['doc']})" for x in data[0]["onnx"]])
            )
            if data[0]["onnx"]
            else "‚ûñ"
        )
        testcases_str = (
            "<br>".join([tc.get("result", tc["testcase"]) for tc in data])
            if data
            else "‚ûñ"
        )
        since = data[0]["since"]
        row = f"| {jax_comp} | {onnx_components} | {testcases_str} | {since} |"
        plugin_rows.append(row)

    # Build table rows for examples.
    example_rows = []
    for (context, component), data in sorted(examples_grouped.items()):
        # For examples we might have additional fields such as description or children.
        description = data[0].get("description", "")
        children = data[0].get("children", [])
        children_str = "<br>".join(children) if children else "‚ûñ"
        testcases_str = (
            "<br>".join([tc.get("result", tc["testcase"]) for tc in data])
            if data
            else "‚ûñ"
        )
        since = data[0]["since"]
        row = f"| {component} | {description} | {children_str} | {testcases_str} | {since} |"
        example_rows.append(row)

    table_header_plugins = (
        "| JAX Component | ONNX Components | Testcases | Since |\n"
        "|:-------------|:---------------|:---------|:------|"
    )
    table_header_examples = (
        "| Component | Description | Children | Testcases | Since |\n"
        "|:----------|:------------|:---------|:---------|:------|"
    )

    table_plugins = "\n".join(plugin_rows)
    table_examples = "\n".join(example_rows)

    with open(README_PATH, "r", encoding="utf-8") as f:
        readme_content = f.read()

    # Replace plugins table.
    start_idx = readme_content.find(START_MARKER)
    end_idx = readme_content.find(END_MARKER)
    if start_idx == -1 or end_idx == -1:
        raise ValueError("Plugin markers not found in README.md")
    new_plugins_section = (
        f"{START_MARKER}\n\n{table_header_plugins}\n{table_plugins}\n\n{END_MARKER}"
    )
    readme_content = (
        readme_content[:start_idx]
        + new_plugins_section
        + readme_content[end_idx + len(END_MARKER) :]
    )

    # Replace examples table.
    start_idx = readme_content.find(EXAMPLES_START_MARKER)
    end_idx = readme_content.find(EXAMPLES_END_MARKER)
    if start_idx == -1 or end_idx == -1:
        raise ValueError("Examples markers not found in README.md")
    new_examples_section = f"{EXAMPLES_START_MARKER}\n\n{table_header_examples}\n{table_examples}\n\n{EXAMPLES_END_MARKER}"
    readme_content = (
        readme_content[:start_idx]
        + new_examples_section
        + readme_content[end_idx + len(EXAMPLES_END_MARKER) :]
    )

    with open(README_PATH, "w", encoding="utf-8") as f:
        f.write(readme_content)

    logging.info("‚úÖ README.md updated successfully!")


# --- Main Execution ---

if __name__ == "__main__":
    start_time = time.time()
    test_results = run_pytest()
    grouped_metadata = get_plugin_grouping()
    update_readme(grouped_metadata, test_results)
    logging.info(f"‚è≥ Total execution time: {time.time() - start_time:.2f}s")
