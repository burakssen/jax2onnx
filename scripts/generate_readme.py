# file: scripts/generate_readme.py
import os
import time
import importlib
import pkgutil
import logging
import subprocess
import json

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(message)s")

# Paths
PLUGIN_DIR = os.path.join(os.path.dirname(__file__), "../jax2onnx/converter/plugins")
EXAMPLES_DIR = os.path.join(os.path.dirname(__file__), "../jax2onnx/examples")
TESTS_DIR = os.path.join(os.path.dirname(__file__), "../tests")  # Add tests directory
README_PATH = os.path.join(os.path.dirname(__file__), "../README.md")

# Markers for the auto-generated sections
START_MARKER = "<!-- AUTOGENERATED TABLE START -->"
END_MARKER = "<!-- AUTOGENERATED TABLE END -->"

EXAMPLES_START_MARKER = "<!-- AUTOGENERATED EXAMPLES TABLE START -->"
EXAMPLES_END_MARKER = "<!-- AUTOGENERATED EXAMPLES TABLE END -->"

NETRON_BASE_URL = "https://netron.app/?url=https://enpasos.github.io/jax2onnx/onnx/"


def run_pytest():
    """Runs pytest and captures actual pass/fail results using JSON output."""
    logging.info("üõ† Running full tests...")

    subprocess.run(
        ["pytest", "--json-report", "--json-report-file=output/pytest_report.json"],
        capture_output=True,
        text=True,
        check=True,  # Raise an exception if pytest fails
    )

    test_results = {}

    # Read the JSON report
    report_path = "output/pytest_report.json"  # Corrected relative path
    if os.path.exists(report_path):
        with open(report_path, "r", encoding="utf-8") as f:
            data = json.load(f)

        for test in data.get("tests", []):
            #  test_plugins.py::Test_plugins_nnx_conv::test_conv_concrete
            parts = test["nodeid"].split("::")
            if len(parts) == 3 and parts[0] == "tests/test_plugins.py":
                class_part = parts[1]  # Test_plugins_nnx_conv
                test_part = parts[2]  # test_conv_concrete
                # Convert from class name back to a context and plugin
                class_parts = class_part.split(
                    "_"
                )  # ['Test', 'plugins', 'nnx', 'conv']
                if len(class_parts) >= 3 and class_parts[0] == "Test":
                    context = class_parts[1:3]  # ['plugins', 'nnx']
                    plugin = class_parts[3:]  # conv

                    # Extract test case name from the test function name
                    testcase_name = test_part.replace("test_", "")

                    status = "‚úÖ" if test["outcome"] == "passed" else "‚ùå"
                    key = (".".join(context), "_".join(plugin), testcase_name)
                    test_results[key] = status

    logging.info(f"‚úÖ Tests completed. {len(test_results)} results captured.")

    # nice print of test results
    for key, value in test_results.items():
        print(f"{key}: {value}")

    return test_results


def extract_metadata(base_path, source_type):
    """Dynamically loads metadata from plugins/examples."""
    logging.info(f"üì° Extracting metadata from {source_type.lower()}s...")

    metadata_list = []

    if source_type.lower() == "plugins":
        for _, name, _ in pkgutil.walk_packages(
            [base_path], prefix=f"jax2onnx.converter.{source_type.lower()}."
        ):
            module = importlib.import_module(name)
            if hasattr(module, "get_metadata"):
                md = module.get_metadata()
                # Standardize metadata format to match example's format
                if isinstance(md, dict):  # For plugins
                    entry = {
                        "jax_component": md.get("jaxpr_primitive", "Unknown"),
                        "jax_doc": md.get("jax_doc", ""),
                        "onnx": md.get("onnx", []),
                        "since": md.get("since", ""),
                        "testcases": {
                            tc.get("testcase", ""): "‚ûñ"
                            for tc in md.get(
                                "testcases", []
                            )  # Initial state before test results
                        },
                        "context": md.get(
                            "context", "default"
                        ),  # Store context for result parsing.
                    }
                    metadata_list.append(entry)

    elif source_type.lower() == "examples":  # Corrected string comparison
        for _, name, _ in pkgutil.walk_packages(
            [base_path], prefix=f"jax2onnx.{source_type.lower()}."
        ):
            module = importlib.import_module(name)
            if hasattr(module, "get_test_params"):
                for entry in module.get_test_params():  # type: ignore
                    # Ensure that 'testcases' is a dictionary with initial values
                    entry["testcases"] = {
                        tc["testcase"]: "‚ûñ" for tc in entry.get("testcases", [])
                    }
                    metadata_list.append(entry)

    logging.info(f"‚úÖ {len(metadata_list)} {source_type.lower()} components found.")
    return metadata_list


def update_readme(metadata_plugins, metadata_examples, test_results):
    """Updates README.md with two auto-generated tables."""
    logging.info("üìÑ Updating README...")

    # Table headers
    table_header_plugins = """
| JAX Component | ONNX Components | Testcases | Since |
|:-------------|:---------------|:---------|:------|
""".strip()

    table_header_examples = """
| Component | Description | Children | Testcases | Since |
|:----------|:------------|:---------|:---------|:------|
""".strip()

    # Sort plugins & examples
    metadata_plugins = sorted(metadata_plugins, key=lambda x: x["jax_component"])
    metadata_examples = sorted(metadata_examples, key=lambda x: x["component"])

    # Generate plugins table
    plugin_rows = []
    for entry in metadata_plugins:
        onnx_links = "<br>".join(
            [f"[{op['component']}]({op['doc']})" for op in entry["onnx"]]
        )

        testcases_column = []
        for base_name in sorted(entry.get("testcases", {}).keys()):
            context = entry.get("context", "default")  # Retrieve context
            plugin = get_plugin_from_source(entry.get("jax_component", "default"))
            status = test_results.get((context, plugin, base_name), "‚ûñ")
            # Construct URL for Netron, handling dynamic/concrete suffixes.
            parts = base_name.split("_")
            if parts[-1] in ("dynamic", "concrete"):
                testcase_name = "_".join(parts[:-1])  # remove dynamic, concrete
                variant = parts[-1]
            else:
                testcase_name = base_name
                variant = ""  # no variant

            url = f"{NETRON_BASE_URL}{context.replace('.', '/')}/{testcase_name}{'_' + variant if variant else ''}.onnx"

            testcase_row = f"`{base_name}` [{status}]({url})"
            testcases_column.append(testcase_row)

        testcases_column = "<br>".join(testcases_column) if testcases_column else "‚ûñ"
        plugin_rows.append(
            f"| [{entry['jax_component']}]({entry['jax_doc']}) "
            f"| {onnx_links} "
            f"| {testcases_column} "
            f"| {entry['since']} |"
        )

    # Generate examples table
    example_rows = []
    for entry in metadata_examples:
        children_list = "<br>".join(entry["children"])

        testcases_column = []
        for base_name in sorted(entry.get("testcases", {}).keys()):
            # Construct URL for Netron.
            url = f"{NETRON_BASE_URL}examples/{base_name}.onnx"

            # Status is simpler for examples, as they are grouped under Test_examples
            status = test_results.get(("examples", "examples", base_name), "‚ûñ")  # type: ignore
            testcase_row = f"`{base_name}` [{status}]({url})"
            testcases_column.append(testcase_row)

        testcases_column = "<br>".join(testcases_column) if testcases_column else "‚ûñ"
        example_rows.append(
            f"| {entry['component']} "
            f"| {entry['description']} "
            f"| {children_list} "
            f"| {testcases_column} "
            f"| {entry['since']} |"
        )

    table_plugins = "\n".join(plugin_rows)
    table_examples = "\n".join(example_rows)

    # Read and update README content
    with open(README_PATH, "r", encoding="utf-8") as file:
        readme_content = file.read()

    # Insert plugins table
    start_idx = readme_content.find(START_MARKER)
    end_idx = readme_content.find(END_MARKER)
    if (start_idx == -1) or (end_idx == -1):
        raise ValueError("Start or End marker for plugins not found in README.md")

    readme_content = (
        readme_content[: start_idx + len(START_MARKER)]
        + f"\n\n{table_header_plugins}\n{table_plugins}\n\n"
        + readme_content[end_idx:]
    )

    # Insert examples table
    start_idx = readme_content.find(EXAMPLES_START_MARKER)
    end_idx = readme_content.find(EXAMPLES_END_MARKER)
    if (start_idx == -1) or (end_idx == -1):
        raise ValueError("Start or End marker for examples not found in README.md")

    readme_content = (
        readme_content[: start_idx + len(EXAMPLES_START_MARKER)]
        + f"\n\n{table_header_examples}\n{table_examples}\n\n"
        + readme_content[end_idx:]
    )

    # Write back to README.md
    with open(README_PATH, "w", encoding="utf-8") as file:
        file.write(readme_content)

    logging.info("‚úÖ README.md updated successfully!")


def get_plugin_from_source(source: str) -> str:
    if "." not in source:
        return source
    return source.split(".")[-1]


if __name__ == "__main__":
    start_time = time.time()

    test_results = run_pytest()  # Run full tests and capture pass/fail
    metadata_plugins = extract_metadata(PLUGIN_DIR, "plugins")
    metadata_examples = extract_metadata(EXAMPLES_DIR, "examples")
    update_readme(metadata_plugins, metadata_examples, test_results)

    logging.info(f"‚è≥ Total execution time: {time.time() - start_time:.2f}s")
