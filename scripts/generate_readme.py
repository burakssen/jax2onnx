# file: scripts/generate_readme.py

import os
import time
import importlib
import pkgutil
import logging
import subprocess
import json

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(message)s")

# Paths
PLUGIN_DIR = os.path.join(os.path.dirname(__file__), "../jax2onnx/plugins")
README_PATH = os.path.join(os.path.dirname(__file__), "../README.md")

# Markers for the auto-generated section
START_MARKER = "<!-- AUTOGENERATED TABLE START -->"
END_MARKER = "<!-- AUTOGENERATED TABLE END -->"


def run_pytest():
    """Runs pytest and captures actual pass/fail results using JSON output."""
    logging.info("üõ† Running full tests...")

    subprocess.run(
        ["pytest", "--json-report", "--json-report-file=output/pytest_report.json"],
        capture_output=True,
        text=True,
    )

    test_results = {}

    # Read the JSON report
    report_path = "output/pytest_report.json"
    if os.path.exists(report_path):
        with open(report_path, "r", encoding="utf-8") as f:
            data = json.load(f)

        for test in data.get("tests", []):
            if "test_onnx_export[" in test["nodeid"]:
                testcase = test["nodeid"].split("[")[-1].rstrip("]")
                status = "‚úÖ" if test["outcome"] == "passed" else "‚ùå"
                test_results[testcase] = status

    logging.info(f"‚úÖ {len(test_results)} tests completed.")
    return test_results


def extract_metadata():
    """Dynamically loads metadata from plugins."""
    logging.info("üì° Extracting metadata from plugins...")

    metadata_list = []
    for _, name, _ in pkgutil.walk_packages([PLUGIN_DIR], prefix="jax2onnx.plugins."):
        module = importlib.import_module(name)
        if hasattr(module, "get_test_params"):
            for entry in module.get_test_params():
                entry["testcases"] = {
                    tc["testcase"]: "‚ûñ" for tc in entry.get("testcases", [])
                }
                if "jax_component" in entry:
                    metadata_list.append(entry)

    logging.info(f"‚úÖ {len(metadata_list)} components found.")
    return metadata_list


def update_readme(metadata, test_results):
    """Updates README.md based on extracted metadata while preserving content outside the auto-generated section."""
    logging.info("üìÑ Updating README...")

    # Table structure
    table_header = """
    | JAX Component | ONNX Components | Since | Testcases |
    |:-------------|:---------------|:------|:---------|
    """.strip()

    # Sort metadata by JAX component name
    metadata_sorted = sorted(metadata, key=lambda x: x["jax_component"])

    table_rows = []
    for entry in metadata_sorted:

        # Extract ONNX component links
        onnx_links = "<br>".join(
            [f"[{op['component']}]({op['doc']})" for op in entry["onnx"]]
        )

        # Sort test cases by name before formatting
        sorted_testcases = sorted(entry.get("testcases", {}).keys())

        # Update test results in the table
        if not sorted_testcases:
            testcases_column = "‚ûñ"  # No testcases
        else:
            testcases_column = "<br>".join(
                [f"{tc} {test_results.get(tc, '‚ùå')}" for tc in sorted_testcases]
            )

        # Build row entry
        table_rows.append(
            f"| [{entry['jax_component']}]({entry['jax_doc']}) "
            f"| {onnx_links} "
            f"| {entry['since']} "
            f"| {testcases_column} |"
        )

    table_content = "\n".join(table_rows)

    # Read existing README content
    with open(README_PATH, "r", encoding="utf-8") as file:
        readme_content = file.read()

    # Locate existing auto-generated section
    start_idx = readme_content.find(START_MARKER)
    end_idx = readme_content.find(END_MARKER)

    if start_idx == -1 or end_idx == -1:
        raise ValueError("Start or End marker not found in README.md")

    # Preserve everything before and after the markers
    before_table = readme_content[: start_idx + len(START_MARKER)]
    after_table = readme_content[end_idx:]

    # Create new README content
    updated_content = (
        f"{before_table}\n\n{table_header}\n{table_content}\n\n{after_table}"
    )

    # Write back to README.md
    with open(README_PATH, "w", encoding="utf-8") as file:
        file.write(updated_content)

    logging.info("‚úÖ README.md updated successfully!")


if __name__ == "__main__":
    start_time = time.time()

    test_results = run_pytest()  # Run full tests to capture pass/fail results
    metadata = extract_metadata()
    update_readme(metadata, test_results)

    logging.info(f"‚è≥ Total execution time: {time.time() - start_time:.2f}s")
